#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

// Function prototypes
vector<string> parseCSV(const string& row);
void createFile(const string& filename);
void createTable(const string& line);
void insertIntoTable(const string& line);
void displayTables();
void processLine(const string& line, const string& filename);
void displayDatabasePath(const string& filename);
void writeToOutputFile(const string& message);
void processDeleteData(const string& deleteCommand);

// Function to parse CSV (removes parentheses and single quotes)
// Debugging to check parsed CSV
vector<string> parseCSV(const string& row) {
    vector<string> result;
    stringstream ss(row);
    string value;

    while (getline(ss, value, ',')) {
        // Remove surrounding spaces and quotes
        value.erase(remove(value.begin(), value.end(), ' '), value.end());

        // Remove any surrounding quotes
        if (value.front() == '\'' || value.front() == '\"') {
            value = value.substr(1, value.length() - 2);
        }

        // Remove any unwanted parentheses or special characters
        if (value.front() == '(' || value.back() == ')') {
            value = value.substr(1, value.length() - 2);  // Remove parentheses
        }

        result.push_back(value);
    }
    return result;
}



// Store created tables and their data
unordered_set<string> createdTables;
unordered_map<string, vector<string>> tableData;
ofstream outputFile;  // Output file stream

void writeToOutputFile(const string& message) {
    cout << message << endl;        // Display on screen
    if (outputFile.is_open()) {
        outputFile << message << endl;  // Write to file
    }
}

void createFile(const string& filename) {
    outputFile.open(filename);
    if (outputFile) {
        writeToOutputFile("CREATE " + filename);
    } else {
        writeToOutputFile("Error creating file: " + filename);
    }
}

void createTable(const string& line) {
    size_t pos = line.find("TABLE") + 6;  // Get position after "CREATE TABLE "
    size_t endPos = line.find('(', pos); // Find position of '('
    string tableName = line.substr(pos, endPos - pos); // Extract table name
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

    if (createdTables.find(tableName) == createdTables.end()) {
        createdTables.insert(tableName);
    } else {
        writeToOutputFile("Table already exists: " + tableName);
    }
}

void insertIntoTable(const string& line) {
    size_t pos = line.find("INSERT INTO") + 11; // Position after "INSERT INTO "
    size_t tableEnd = line.find('(', pos);      // End of table name
    string tableName = line.substr(pos, tableEnd - pos);
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

    if (createdTables.find(tableName) == createdTables.end()) {
        writeToOutputFile("Table does not exist: " + tableName);
        return;
    }

    size_t valuesPos = line.find("VALUES", tableEnd) + 6; // Position after "VALUES"
    string values = line.substr(valuesPos);
    values.erase(remove_if(values.begin(), values.end(), ::isspace), values.end());

    // Remove parentheses and quotes around values
    if (values.front() == '(' && values.back() == ')') {
        values = values.substr(1, values.length() - 2); // Remove outer parentheses
    }

    // Remove single quotes around each value
    size_t posStart = 0;
    while ((posStart = values.find('\'', posStart)) != string::npos) {
        values.erase(posStart, 1);  // Remove single quotes
    }

    tableData[tableName].push_back(values);  // Store the row without parentheses and quotes
    writeToOutputFile("Inserted into table " + tableName + ": " + values);
}

void displayTables() {
    if (createdTables.empty()) {
        writeToOutputFile("No tables have been created.");
    } else {
        for (const string& tableName : createdTables) {
            writeToOutputFile(tableName);
        }
    }
}

void displayDatabasePath(const string& filename) {
    writeToOutputFile(filename);
}

void processDeleteData(const string& deleteCommand) {
    size_t fromPos = deleteCommand.find("DELETE FROM");
    size_t wherePos = deleteCommand.find("WHERE");

    if (fromPos == string::npos || wherePos == string::npos) {
        cout << "Invalid DELETE statement." << endl;
        return;
    }

    // Extract table name (between "DELETE FROM" and "WHERE")
    string tableName = deleteCommand.substr(fromPos + 11, wherePos - (fromPos + 11));
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());  // Trim spaces

    // Print out the table name for confirmation
    cout << "Table: " << tableName << endl;

    // Extract condition value (after "=")
    size_t equalPos = deleteCommand.find("=", wherePos);
    if (equalPos == string::npos) {
        cout << "Invalid DELETE statement." << endl;
        return;
    }

    string value = deleteCommand.substr(equalPos + 1);
    value.erase(remove_if(value.begin(), value.end(), ::isspace), value.end());  // Trim spaces
    if (value.front() == '\'' || value.front() == '\"') {
        value = value.substr(1, value.length() - 2);  // Remove surrounding quotes
    }

    // Print out the value for confirmation
    cout << "Value: " << value << endl;

    // Check if table exists in tableData
    if (tableData.find(tableName) == tableData.end()) {
        cout << "Table not found: " << tableName << endl;
        return;
    }

    // Get the rows of the specified table
    vector<string> rows = tableData[tableName];

    // Iterate through the rows (skip header)
    for (size_t i = 1; i < rows.size(); ++i) {
        string row = rows[i];

        // Find the first comma in the row
        size_t pos = row.find(',');

        // Extract the value before the comma (assuming it's the ID value)
        if (pos != string::npos) {
            string valueBeforeComma = row.substr(0, pos);

            // Debug: Print the value before the comma to see what's inside
            cout << "Row: " << row << endl;
            cout << "Value before comma: '" << valueBeforeComma << "'" << endl;
            cout << "Comparing with: '" << value << "'" << endl;

            // If the value before the comma matches the DELETE value, print the row
            if (valueBeforeComma == value) {
                cout << "Matching row: " << row << endl;
            }
        }
    }
}



void processLine(const string& line, const string& filename) {
    // Print each line
    writeToOutputFile(line);

    if (line.find("CREATE") != string::npos) {
        // Check if it's CREATE FILE or CREATE TABLE
        size_t pos = line.find("CREATE") + 6;
        size_t spacePos = line.find(' ', pos);
        string fileName = line.substr(spacePos + 1);
        fileName.erase(remove_if(fileName.begin(), fileName.end(), ::isspace), fileName.end());

        // If it's creating a file (not a table), just create the file
        if (line.find("TABLE") == string::npos) {
            createFile(fileName);
        }
        // Otherwise, create the table
        else {
            createTable(line);
        }
    } else if (line.find("DATABASES") != string::npos) {
        displayDatabasePath(filename);
    } else if (line.find("TABLES") != string::npos) {
        displayTables();
    } else if (line.find("INSERT INTO") != string::npos) {
        insertIntoTable(line);
    } else if (line.find("SELECT COUNT(*) FROM") != string::npos) {
        string tableName = line.substr(20, line.find(';') - 20);
        tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

        if (createdTables.find(tableName) == createdTables.end()) {
            writeToOutputFile("Table does not exist: " + tableName);
        } else {
            size_t rowCount = tableData[tableName].size();
            writeToOutputFile(to_string(rowCount));
        }
    } else if (line.find("SELECT * FROM") != string::npos) {
        string tableName = line.substr(14, line.find(';') - 14);
        tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

        if (createdTables.find(tableName) == createdTables.end()) {
            writeToOutputFile("Table does not exist: " + tableName);
        } else {

            // Assuming column names are stored in the first row or manually defined
            writeToOutputFile("customer_id, customer_name, customer_city, customer_state, customer_country, customer_phone, customer_email");
            for (const string& row : tableData[tableName]) {
                string cleanedRow = row;

                // Remove parentheses
                cleanedRow.erase(remove(cleanedRow.begin(), cleanedRow.end(), '('), cleanedRow.end());
                cleanedRow.erase(remove(cleanedRow.begin(), cleanedRow.end(), ')'), cleanedRow.end());

                // Remove single quotes from the values
                size_t posStart = 0;
                while ((posStart = cleanedRow.find('\'', posStart)) != string::npos) {
                    cleanedRow.erase(posStart, 1);  // Remove single quotes
                }

                writeToOutputFile(cleanedRow);  // Display data without parentheses and quotes
            }
        }
    } else if (line.find("DELETE FROM") != string::npos) {
        processDeleteData(line);  // Pass 'line' directly as an argument
    }
}

int main() {
    string basePath = "C:\\Users\\User\\Projects\\Light_Mariadb_Interpreter\\data\\";  // Base directory
    string fileInput;

    cout << "Enter the .mdb file name: ";
    getline(cin, fileInput);
    string filename = basePath + fileInput;

    ifstream infile(filename);

    if (infile.fail()) {
        writeToOutputFile("Error opening file: " + filename);
    } else {
        string line;
        while (getline(infile, line)) {
            processLine(line, filename);
        }
        infile.close();
    }

    if (outputFile.is_open()) {
        outputFile.close();  // Close the output file after processing
    }

    return 0;
}

********* compare already
