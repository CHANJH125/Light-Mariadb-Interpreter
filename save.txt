#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

// Function prototypes
vector<string> parseCSV(const string& row);
void createFile(const string& filename);
void createTable(const string& line);
void insertIntoTable(const string& line);
void displayTables();
void processLine(const string& line, const string& filename);
void displayDatabasePath(const string& filename);
void writeToOutputFile(const string& message);
void processDeleteData(const string& deleteCommand);
void processUpdateData(const string& updateCommand);

// Function to parse CSV (removes parentheses and single quotes)
// Debugging to check parsed CSV
vector<string> parseCSV(const string& row) {
    vector<string> result;
    stringstream ss(row);
    string value;

    while (getline(ss, value, ',')) {
        // Remove surrounding spaces and quotes
        value.erase(remove(value.begin(), value.end(), ' '), value.end());

        // Remove any surrounding quotes
        if (value.front() == '\'' || value.front() == '\"') {
            value = value.substr(1, value.length() - 2);
        }

        // Remove any unwanted parentheses or special characters
        if (value.front() == '(' || value.back() == ')') {
            value = value.substr(1, value.length() - 2);  // Remove parentheses
        }

        result.push_back(value);
    }
    return result;
}



// Store created tables and their data
unordered_set<string> createdTables;
unordered_map<string, vector<string>> tableData;
ofstream outputFile;  // Output file stream

void writeToOutputFile(const string& message) {
    if (!message.empty()) {  // Only write if the message is not empty
        cout << message << endl;  // Display on screen
        if (outputFile.is_open()) {
            outputFile << message << endl;  // Write to file
        }
    }
}


void createFile(const string& filename) {
    outputFile.open(filename);
    if (outputFile) {
        writeToOutputFile(">CREATE " + filename);
    } else {
        writeToOutputFile("Error creating file: " + filename);
    }
}

void createTable(const string& line) {
    size_t pos = line.find("TABLE") + 6;  // Get position after "CREATE TABLE "
    size_t endPos = line.find('(', pos); // Find position of '('
    string tableName = line.substr(pos, endPos - pos); // Extract table name
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

    if (createdTables.find(tableName) == createdTables.end()) {
        createdTables.insert(tableName);
    } else {
        writeToOutputFile("Table already exists: " + tableName);
    }
}

void insertIntoTable(const string& line) {
    size_t pos = line.find("INSERT INTO") + 11; // Position after "INSERT INTO "
    size_t tableEnd = line.find('(', pos);      // End of table name
    string tableName = line.substr(pos, tableEnd - pos);
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

    if (createdTables.find(tableName) == createdTables.end()) {
        writeToOutputFile("Table does not exist: " + tableName);
        return;
    }

    size_t valuesPos = line.find("VALUES", tableEnd) + 6; // Position after "VALUES"
    string values = line.substr(valuesPos);
    values.erase(remove_if(values.begin(), values.end(), ::isspace), values.end());

    // Remove parentheses and quotes around values
    if (values.front() == '(' && values.back() == ')') {
        values = values.substr(1, values.length() - 2); // Remove outer parentheses
    }

    // Remove single quotes around each value
    size_t posStart = 0;
    while ((posStart = values.find('\'', posStart)) != string::npos) {
        values.erase(posStart, 1);  // Remove single quotes
    }

    tableData[tableName].push_back(values);  // Store the row without parentheses and quotes
}

void displayTables() {
    if (createdTables.empty()) {
        writeToOutputFile("No tables have been created.");
    } else {
        for (const string& tableName : createdTables) {
            writeToOutputFile(tableName);
        }
    }
}

void displayDatabasePath(const string& filename) {
    writeToOutputFile(filename);
}

void processDeleteData(const string& deleteCommand) {
    // Extract the value after WHERE (in your case, customer_id=4)
    size_t pos = deleteCommand.find("WHERE customer_id=");
    if (pos != string::npos) {
        // Extract the number after "WHERE customer_id="
        string valueToDelete = deleteCommand.substr(pos + 18);  // Skip past "WHERE customer_id="
        valueToDelete = valueToDelete.substr(0, valueToDelete.find(';'));  // Get the value before ';'

        // Clean the value to remove any unwanted characters (like spaces)
        valueToDelete.erase(remove_if(valueToDelete.begin(), valueToDelete.end(), ::isspace), valueToDelete.end());

        // Now, check each row in the customer table
        bool found = false;
        for (auto it = tableData["customer"].begin(); it != tableData["customer"].end(); ++it) {
            string row = *it;
            // Clean the row to get the value before the first comma
            size_t posComma = row.find(',');
            string valueBeforeComma = row.substr(1, posComma - 1);  // Extract the number inside parentheses (before the comma)

            // Compare the value before comma with the valueToDelete
            if (valueBeforeComma == valueToDelete) {
                tableData["customer"].erase(it);  // Remove the row if it matches
                found = true;
                break;  // Exit loop after deleting the row
            }
        }

        if (!found) {
            writeToOutputFile("No matching row found for customer_id=" + valueToDelete);
        }
    } else {
        writeToOutputFile("Invalid DELETE command.");
    }
}

void processUpdateData(const string& updateCommand) {
    // Find the position of SET and WHERE in the updateCommand
    size_t setPos = updateCommand.find("SET ");
    size_t wherePos = updateCommand.find("WHERE");

    if (setPos == string::npos || wherePos == string::npos) {
        writeToOutputFile("Invalid UPDATE command.");
        return;
    }

    // Extract the table name (assumed to be after "UPDATE ")
    string tableName = updateCommand.substr(6, setPos - 6);
    tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end()); // Remove spaces

    if (tableName != "customer") {
        writeToOutputFile("Invalid table name: " + tableName);
        return;
    }

    // Extract the SET clause (e.g., customer_email='email333')
    string setClause = updateCommand.substr(setPos + 4, wherePos - setPos - 4);

    // Parse the SET clause to extract the column and the new value
    size_t equalPos = setClause.find('=');
    if (equalPos == string::npos) {
        writeToOutputFile("Invalid SET clause in UPDATE command.");
        return;
    }

    string columnToUpdate = setClause.substr(0, equalPos);
    string newValue = setClause.substr(equalPos + 1);

    columnToUpdate.erase(remove_if(columnToUpdate.begin(), columnToUpdate.end(), ::isspace), columnToUpdate.end());
    newValue.erase(remove_if(newValue.begin(), newValue.end(), ::isspace), newValue.end());

    // Extract the WHERE condition (e.g., customer_id=3)
    string wherePart = updateCommand.substr(wherePos + 6);  // After "WHERE "
    wherePart.erase(remove_if(wherePart.begin(), wherePart.end(), ::isspace), wherePart.end());

    size_t whereEqualPos = wherePart.find('=');
    if (whereEqualPos == string::npos) {
        writeToOutputFile("Invalid WHERE condition in UPDATE command.");
        return;
    }

    string whereColumn = wherePart.substr(0, whereEqualPos);
    string whereValue = wherePart.substr(whereEqualPos + 1);
    whereColumn.erase(remove_if(whereColumn.begin(), whereColumn.end(), ::isspace), whereColumn.end());

    // Remove any trailing semicolon and trim spaces from whereValue
    whereValue.erase(remove(whereValue.begin(), whereValue.end(), ';'), whereValue.end());
    whereValue.erase(remove_if(whereValue.begin(), whereValue.end(), ::isspace), whereValue.end());

    // Print the value to match for the WHERE condition
//    writeToOutputFile("Value to match: '" + whereValue + "'");

    // Now check each row and replace the value based on the first number before the first comma
    bool found = false;
    for (auto it = tableData["customer"].begin(); it != tableData["customer"].end(); ++it) {
        string row = *it;

        // Extract the customer_id (first column value) by getting the substring before the first comma
        size_t posComma = row.find(',');
        string valueBeforeComma = row.substr(0, posComma);  // Extract the customer_id

        // Remove parentheses from customer_id if present
        if (!valueBeforeComma.empty() && valueBeforeComma[0] == '(') {
            valueBeforeComma = valueBeforeComma.substr(1);  // Remove the '('
        }
        if (!valueBeforeComma.empty() && valueBeforeComma.back() == ')') {
            valueBeforeComma = valueBeforeComma.substr(0, valueBeforeComma.size() - 1);  // Remove the ')'
        }

        // Trim spaces if any
        valueBeforeComma.erase(remove_if(valueBeforeComma.begin(), valueBeforeComma.end(), ::isspace), valueBeforeComma.end());
        whereValue.erase(remove_if(whereValue.begin(), whereValue.end(), ::isspace), whereValue.end());


        // Check and print their comparison
        if (valueBeforeComma == whereValue) {
            // Split the row by commas into substrings
            vector<string> columns;
            size_t startPos = 0;
            size_t commaPos = 0;
            while ((commaPos = row.find(',', startPos)) != string::npos) {
                columns.push_back(row.substr(startPos, commaPos - startPos));
                startPos = commaPos + 1;
            }
            // Don't forget the last column (after the last comma)
            columns.push_back(row.substr(startPos));

            // Update the column value after the 6th comma (7th column)
            columns[6] = newValue;  // Assuming 'customer_email' is the 7th column

            // Rebuild the row with updated value
            string updatedRow = "";
            for (size_t i = 0; i < columns.size(); ++i) {
                updatedRow += columns[i];
                if (i != columns.size() - 1) {
                    updatedRow += ",";
                }
            }

            // Update the row in the table
            tableData["customer"][distance(tableData["customer"].begin(), it)] = updatedRow;
            found = true;
            break;  // Exit loop after updating the row
        } else {
        }
    }

    if (!found) {
        writeToOutputFile("No matching row found for customer_id=" + whereValue);
    }
}


void processLine(const string& line, const string& filename) {
    // Skip empty or whitespace-only lines
    if (line.empty() || line.find_first_not_of(" \t\n\r") == string::npos) {
        return;  // Skip this line
    }

    // Add '>' before the commands like CREATE, INSERT, DATABASES, etc.
    string modifiedLine = line;
    bool isCommand = false;

    if (modifiedLine.find("CREATE") != string::npos ||
        modifiedLine.find("DATABASES") != string::npos ||
        modifiedLine.find("INSERT INTO") != string::npos ||
        modifiedLine.find("SELECT") != string::npos ||
        modifiedLine.find("UPDATE") != string::npos ||
        modifiedLine.find("DELETE") != string::npos ||
        modifiedLine.find("TABLES") != string::npos) {
        modifiedLine = ">" + modifiedLine;
        isCommand = true;
    }

    // If it's a command, print it with '>'
    writeToOutputFile(modifiedLine);

    // Handle different commands as before
    if (line.find("CREATE") != string::npos) {
        // Check if it's CREATE FILE or CREATE TABLE
        size_t pos = line.find("CREATE") + 6;
        size_t spacePos = line.find(' ', pos);
        string fileName = line.substr(spacePos + 1);
        fileName.erase(remove_if(fileName.begin(), fileName.end(), ::isspace), fileName.end());

        // If it's creating a file (not a table), just create the file
        if (line.find("TABLE") == string::npos) {
            createFile(fileName);
        }
        // Otherwise, create the table
        else {
            createTable(line);
        }
    } else if (line.find("DATABASES") != string::npos) {
        displayDatabasePath(filename);
    } else if (line.find("TABLES") != string::npos) {
        displayTables();
    } else if (line.find("INSERT INTO") != string::npos) {
        insertIntoTable(line);
    } else if (line.find("SELECT COUNT(*) FROM") != string::npos) {
        string tableName = line.substr(20, line.find(';') - 20);
        tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

        if (createdTables.find(tableName) == createdTables.end()) {
            writeToOutputFile("> Table does not exist: " + tableName);
        } else {
            size_t rowCount = tableData[tableName].size();

            // Write the count without the '>' symbol
            writeToOutputFile(to_string(rowCount));  // Directly write the count without ">"
        }
    } else if (line.find("SELECT * FROM") != string::npos) {
        string tableName = line.substr(14, line.find(';') - 14);
        tableName.erase(remove_if(tableName.begin(), tableName.end(), ::isspace), tableName.end());

        if (createdTables.find(tableName) == createdTables.end()) {
            writeToOutputFile("> Table does not exist: " + tableName);
        } else {
            // Assuming column names are stored in the first row or manually defined
            writeToOutputFile("customer_id, customer_name, customer_city, customer_state, customer_country, customer_phone, customer_email");
            for (const string& row : tableData[tableName]) {
                string cleanedRow = row;

                // Remove parentheses
                cleanedRow.erase(remove(cleanedRow.begin(), cleanedRow.end(), '('), cleanedRow.end());
                cleanedRow.erase(remove(cleanedRow.begin(), cleanedRow.end(), ')'), cleanedRow.end());

                // Remove single quotes from the values
                size_t posStart = 0;
                while ((posStart = cleanedRow.find('\'', posStart)) != string::npos) {
                    cleanedRow.erase(posStart, 1);  // Remove single quotes
                }

                writeToOutputFile(cleanedRow);  // Display data without '>'
            }
        }
    } else if (line.find("DELETE FROM") != string::npos) {
        processDeleteData(line);  // Pass 'line' directly as an argument
    } else if (line.find("UPDATE") != string::npos) {
        processUpdateData(line);  // Pass the UPDATE command directly to the function
    }
}

int main() {
    string basePath = "C:\\Users\\User\\Projects\\Light_Mariadb_Interpreter\\data\\";  // Base directory
    string fileInput;

    cout << "Enter the .mdb file name: ";
    getline(cin, fileInput);
    string filename = basePath + fileInput;

    ifstream infile(filename);

    if (infile.fail()) {
        writeToOutputFile("Error opening file: " + filename);
    } else {
        string line;
        while (getline(infile, line)) {
            processLine(line, filename);
        }
        infile.close();
    }

    if (outputFile.is_open()) {
        outputFile.close();  // Close the output file after processing
    }

    return 0;
}
